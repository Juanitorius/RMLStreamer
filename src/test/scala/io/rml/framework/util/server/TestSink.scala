package io.rml.framework.util.server

import akka.actor.{ActorSystem, Cancellable}
import io.rml.framework.util.logging.Logger
import org.apache.flink.streaming.api.functions.sink.SinkFunction

import scala.concurrent.duration._
import scala.concurrent.{ExecutionContextExecutor, Future, Promise}

/**
  * This object will collect the output of rml generation from a data stream into
  * list of string. The list will be synchronized across the threads.
  *
  * The synchronization lock will be the object itself
  */
object TestSink extends SinkFunction[String] {

  private val actorSystem = ActorSystem()
  implicit val executor: ExecutionContextExecutor = actorSystem.dispatcher
  private var scheduledTask: Option[Cancellable] = None

  var sinkPromise: Promise[Boolean] = synchronized {
    Promise()
  }

  var sinkFuture: Future[Boolean] = synchronized {
    sinkPromise.future
  }
  /**
    * Need a List and Set for the generated triples since there might be
    * duplicates generated by the mapper in some situations.
    */
  private var triples: List[String] = List[String]()

  private var setTriples: Set[String] = Set[String]()

  private var expectedTriples: Set[String] = Set[String]()


  def startCountDown(delay: FiniteDuration): Unit = synchronized {
    Logger.logInfo(s"${this}")


    val task =

      actorSystem.scheduler.scheduleOnce(delay) {
        Logger.logInfo(s"Sink's Promise status: ${sinkPromise.isCompleted}")
        Logger.logInfo("START SINK COUNTDOWN")
        sinkPromise success true
      }


    scheduledTask = Some(task)

    Logger.logInfo(scheduledTask.toString)
  }


  def getTriples: List[String] = synchronized {
    triples
  }


  def reset(): Unit = synchronized {
    triples = List()
    setTriples = Set()
    expectedTriples = Set()
    scheduledTask = None
    sinkPromise = Promise()
    sinkFuture = sinkPromise.future
  }

  def setExpectedTriples(triples: Iterable[String]): Unit = synchronized {
    expectedTriples = triples.toSet
  }

  def apply(): TestSink = {
    new TestSink()
  }


}

class TestSink extends SinkFunction[String] {

  import TestSink._


  override def invoke(value: String): Unit = {
    TestSink.synchronized {
      Logger.logInfo(s"Sink received [${value}]")
      try {
        if (scheduledTask.isDefined) {
          scheduledTask.get.cancel()
        }
      } catch {
        case e: Throwable => Logger.logError(e.toString)
      }
      Logger.logInfo(value)
      for (el <- value.split('\n')) {
        // List in scala is linked list so prepending is faste
        triples = el :: triples
        setTriples += el
      }

      if (setTriples == expectedTriples) {
        sinkPromise success true
      } else {
        Logger.logInfo("Waiting 3 more seconds for input...")
        startCountDown(3 second)
      }
    }

  }

}
